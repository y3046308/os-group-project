For every question, implementation on error cases were omitted.

1. file descriptor consists of five items: file_flag, filename, file(vnode), offset, and buflen.
   - file_flag indicates what files can do. Ex) Read only, Write Only, Read and Write, etc...
   - filename literally indicates name of the file
   - vnode* file indicates information and location of the file.
   - offset also literally indicates the offset of the file.
   - buflen indicates number of bytes left in the file to write.
   
   - In open, we first check if table of file descriptors are full. If it is, we print error cases. If not, we add the file
     using vfs_open. After open, we add this file to the table.
   - In close, the program checks if file exists at fd in the table of file descriptor. If it does, we close file's vnode
     using vfs_close, free the file descriptor, and set it to NULL.
   - In read, before reading the file, we check if file exists at fd in the table. If it does, we open the file using VOP_READ.
   - In write, we first check if file exists at fd in the table. If it does, we open the file using VOP_WRITE. 
   
2. We assign pids to each process in proc_create that's in kern/proc/proc.c. First we iterate through the array of processes,
  then assign pid to all empty processes in the array. Possible pids are from PID_MIN to PID_MAX.
  
  - Fork just copies every element from current process to new process. 
    -> string p.name, vnode p_cwd
    -> spinlock p_lock
    -> array of threads, p_threads
    -> virtual address space, p_addrspace
    -> copy the trapframe.
    -> thread_fork the function "enter_forked_process"
    -> create new trapframe.
    
  - getpid just reads id of current process. (we have pid declared inside process structure so getting pid of current process is piece of cake).
  - _exit simply ends current process.
    -> saves pid/exitcode pair into exitcarray.
    -> remove thread
    -> thread_exit
    -> signal the waiting processes.
  - waitpid waits for the given process to terminate.
    -> if the process is running, wait with CV
    -> if the process is NOT running, just find its exitcode from exitcarray and return.
  
3. Since we have the process id, we can easily find the process using find_proc function. (It iterates the process array and get the right process using pid)
  If we found the process in the process array, it means that the process is not terminated yet. We used the CV_WAIT to wait until the process terminates.
    (We used cv and lock in the process we are waiting for, because the process must signal when exit.)
  If the process is not found, it means that the process is already terminated. The exitcode might be saved in "codes" array.
  If the exitcode is not found in "codes" array, it means that the given pid is invalid. we need to return error.

4.